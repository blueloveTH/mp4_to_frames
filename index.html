<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>MP4 to Frames</title>
  <script src="lib/vue.global.prod.js"></script>
  <script src="lib/jszip.min.js"></script>
  <style>
    *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

    body {
      font-family: 'Segoe UI', system-ui, sans-serif;
      background: #0f172a;
      color: #e2e8f0;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
    }

    header {
      width: 100%;
      padding: 24px 32px;
      background: linear-gradient(135deg, #1e293b 0%, #0f172a 100%);
      border-bottom: 1px solid #334155;
      text-align: center;
    }

    header h1 {
      font-size: 2rem;
      font-weight: 700;
      background: linear-gradient(90deg, #38bdf8, #818cf8);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      letter-spacing: -0.5px;
    }

    header p {
      margin-top: 6px;
      color: #94a3b8;
      font-size: 0.95rem;
    }

    main {
      width: 100%;
      max-width: 960px;
      padding: 40px 24px;
      flex: 1;
    }

    .card {
      background: #1e293b;
      border: 1px solid #334155;
      border-radius: 16px;
      padding: 32px;
    }

    /* Upload zone */
    .upload-zone {
      border: 2px dashed #334155;
      border-radius: 12px;
      padding: 48px 24px;
      text-align: center;
      cursor: pointer;
      transition: border-color 0.2s, background 0.2s;
    }

    .upload-zone:hover,
    .upload-zone.drag-over {
      border-color: #38bdf8;
      background: rgba(56, 189, 248, 0.05);
    }

    .upload-zone svg {
      width: 48px;
      height: 48px;
      color: #38bdf8;
      margin-bottom: 12px;
    }

    .upload-zone p {
      font-size: 1rem;
      color: #94a3b8;
    }

    .upload-zone .filename {
      margin-top: 8px;
      font-size: 0.9rem;
      color: #38bdf8;
      font-weight: 500;
      word-break: break-all;
    }

    /* Form row */
    .form-row {
      display: flex;
      gap: 16px;
      margin-top: 24px;
      align-items: flex-end;
      flex-wrap: wrap;
    }

    .form-group {
      display: flex;
      flex-direction: column;
      gap: 6px;
      flex: 1;
      min-width: 160px;
    }

    .form-group label {
      font-size: 0.85rem;
      font-weight: 600;
      color: #94a3b8;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .form-group input[type="number"] {
      background: #0f172a;
      border: 1px solid #334155;
      color: #e2e8f0;
      border-radius: 8px;
      padding: 10px 14px;
      font-size: 1rem;
      outline: none;
      transition: border-color 0.2s;
      width: 100%;
    }

    .form-group input[type="number"]:focus {
      border-color: #38bdf8;
    }

    /* Hidden file input */
    #fileInput { display: none; }

    /* Buttons */
    .btn {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      padding: 10px 22px;
      border-radius: 8px;
      font-size: 0.95rem;
      font-weight: 600;
      cursor: pointer;
      border: none;
      transition: opacity 0.2s, transform 0.1s;
    }

    .btn:active { transform: scale(0.97); }
    .btn:disabled { opacity: 0.4; cursor: not-allowed; transform: none; }

    .btn-primary {
      background: linear-gradient(135deg, #38bdf8, #818cf8);
      color: #0f172a;
    }

    .btn-success {
      background: linear-gradient(135deg, #34d399, #059669);
      color: #0f172a;
    }

    /* Progress */
    .progress-wrap {
      margin-top: 28px;
    }

    .progress-label {
      display: flex;
      justify-content: space-between;
      font-size: 0.85rem;
      color: #94a3b8;
      margin-bottom: 8px;
    }

    .progress-bar-bg {
      background: #0f172a;
      border-radius: 999px;
      height: 8px;
      overflow: hidden;
    }

    .progress-bar-fill {
      height: 100%;
      background: linear-gradient(90deg, #38bdf8, #818cf8);
      border-radius: 999px;
      transition: width 0.15s ease;
    }

    /* Results section */
    .results-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 20px;
      flex-wrap: wrap;
      gap: 12px;
    }

    .results-header h2 {
      font-size: 1.2rem;
      font-weight: 600;
      color: #e2e8f0;
    }

    .badge {
      background: #334155;
      color: #94a3b8;
      font-size: 0.8rem;
      font-weight: 600;
      padding: 3px 10px;
      border-radius: 999px;
      margin-left: 8px;
    }

    /* Frames grid */
    .frames-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(160px, 1fr));
      gap: 12px;
      max-height: 600px;
      overflow-y: auto;
      padding: 4px 2px;
    }

    .frames-grid::-webkit-scrollbar { width: 6px; }
    .frames-grid::-webkit-scrollbar-track { background: #0f172a; border-radius: 3px; }
    .frames-grid::-webkit-scrollbar-thumb { background: #334155; border-radius: 3px; }

    .frame-item {
      background: #0f172a;
      border: 1px solid #334155;
      border-radius: 8px;
      overflow: hidden;
      display: flex;
      flex-direction: column;
    }

    .frame-item img {
      width: 100%;
      aspect-ratio: 16/9;
      object-fit: cover;
      display: block;
    }

    .frame-item .frame-label {
      padding: 4px 8px;
      font-size: 0.75rem;
      color: #64748b;
      text-align: center;
    }

    /* Section spacing */
    .section { margin-top: 32px; }

    /* Divider */
    .divider {
      border: none;
      border-top: 1px solid #334155;
      margin: 28px 0;
    }

    .status-msg {
      margin-top: 16px;
      font-size: 0.9rem;
      color: #94a3b8;
      text-align: center;
    }

    .error-msg {
      color: #f87171;
    }
  </style>
</head>
<body>
  <div id="app">
    <header>
      <h1>üé¨ MP4 to Frames</h1>
      <p>Extract frames from any MP4 video at your desired frame rate</p>
    </header>

    <main>
      <div class="card">
        <!-- Upload zone -->
        <div
          class="upload-zone"
          :class="{ 'drag-over': dragging }"
          @click="triggerFileInput"
          @dragover.prevent="dragging = true"
          @dragleave.prevent="dragging = false"
          @drop.prevent="onDrop"
        >
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round">
            <path d="M15 10l4.553-2.277A1 1 0 0121 8.677V15.5a1 1 0 01-1.447.894L15 14M3 8a2 2 0 012-2h10a2 2 0 012 2v8a2 2 0 01-2 2H5a2 2 0 01-2-2V8z"/>
          </svg>
          <p>Click or drag &amp; drop an MP4 file here</p>
          <p v-if="file" class="filename">üìÅ {{ file.name }} ({{ fileSizeMB }} MB)</p>
        </div>
        <input id="fileInput" type="file" accept="video/mp4,video/*" @change="onFileChange" />

        <!-- Frame rate input + submit -->
        <div class="form-row">
          <div class="form-group">
            <label for="fps">Target Frame Rate (fps)</label>
            <input id="fps" type="number" v-model.number="fps" min="0.1" max="60" step="0.1" placeholder="e.g. 1" />
          </div>
          <button
            class="btn btn-primary"
            :disabled="!file || fps <= 0 || processing"
            @click="processVideo"
          >
            <span v-if="processing">Processing‚Ä¶</span>
            <span v-else>Extract Frames</span>
          </button>
        </div>

        <!-- Progress -->
        <div v-if="processing" class="progress-wrap">
          <div class="progress-label">
            <span>{{ progressLabel }}</span>
            <span>{{ progressPct }}%</span>
          </div>
          <div class="progress-bar-bg">
            <div class="progress-bar-fill" :style="{ width: progressPct + '%' }"></div>
          </div>
        </div>

        <!-- Error -->
        <p v-if="errorMsg" class="status-msg error-msg">‚ö†Ô∏è {{ errorMsg }}</p>

        <!-- Results -->
        <template v-if="frames.length">
          <hr class="divider" />
          <div class="section">
            <div class="results-header">
              <h2>Preview <span class="badge">{{ frames.length }} frames</span></h2>
              <button class="btn btn-success" :disabled="zipping" @click="downloadZip">
                <span v-if="zipping">Preparing ZIP‚Ä¶</span>
                <span v-else>‚¨á Download ZIP</span>
              </button>
            </div>
            <div class="frames-grid">
              <div v-for="(frame, i) in frames" :key="i" class="frame-item">
                <img :src="frame" :alt="'Frame ' + (i + 1)" loading="lazy" />
                <div class="frame-label">{{ i + 1 }}.png</div>
              </div>
            </div>
          </div>
        </template>
      </div>
    </main>
  </div>

  <script>
    const { createApp, ref, computed } = Vue;

    createApp({
      setup() {
        const file = ref(null);
        const fps = ref(24);
        const frames = ref([]);
        const processing = ref(false);
        const zipping = ref(false);
        const dragging = ref(false);
        const errorMsg = ref('');
        const progressStep = ref(0);
        const progressTotal = ref(0);

        const fileSizeMB = computed(() =>
          file.value ? (file.value.size / 1024 / 1024).toFixed(2) : '0'
        );

        const progressPct = computed(() => {
          if (progressTotal.value === 0) return 0;
          return Math.round((progressStep.value / progressTotal.value) * 100);
        });

        const progressLabel = computed(() =>
          progressTotal.value > 0
            ? `Extracting frame ${progressStep.value} / ${progressTotal.value}`
            : 'Preparing‚Ä¶'
        );

        function triggerFileInput() {
          document.getElementById('fileInput').click();
        }

        function onFileChange(e) {
          const f = e.target.files[0];
          if (f) setFile(f);
        }

        function onDrop(e) {
          dragging.value = false;
          const f = e.dataTransfer.files[0];
          if (f && (f.type.startsWith('video/') || f.name.endsWith('.mp4'))) {
            setFile(f);
          } else {
            errorMsg.value = 'Please drop a valid video file.';
          }
        }

        function setFile(f) {
          file.value = f;
          frames.value = [];
          errorMsg.value = '';
        }

        async function processVideo() {
          if (!file.value || fps.value <= 0) return;
          processing.value = true;
          errorMsg.value = '';
          frames.value = [];
          progressStep.value = 0;
          progressTotal.value = 0;

          try {
            const url = URL.createObjectURL(file.value);
            const extracted = await extractFrames(url, fps.value);
            frames.value = extracted;
            URL.revokeObjectURL(url);
          } catch (e) {
            errorMsg.value = e.message || 'Failed to process video.';
          } finally {
            processing.value = false;
          }
        }

        function extractFrames(videoUrl, targetFps) {
          return new Promise((resolve, reject) => {
            const video = document.createElement('video');
            video.src = videoUrl;
            video.muted = true;
            video.preload = 'auto';

            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            const result = [];

            video.addEventListener('error', () => reject(new Error('Failed to load video.')));

            video.addEventListener('loadedmetadata', async () => {
              const duration = video.duration;
              if (!isFinite(duration) || duration <= 0) {
                reject(new Error('Cannot determine video duration.'));
                return;
              }

              canvas.width = video.videoWidth;
              canvas.height = video.videoHeight;

              const interval = 1 / targetFps;
              const times = [];
              for (let t = 0; t < duration; t += interval) {
                times.push(parseFloat(t.toFixed(6)));
              }

              progressTotal.value = times.length;

              for (let i = 0; i < times.length; i++) {
                await seekAndCapture(video, canvas, ctx, times[i]);
                result.push(canvas.toDataURL('image/png'));
                progressStep.value = i + 1;
              }

              resolve(result);
            });
          });
        }

        function seekAndCapture(video, canvas, ctx, time) {
          return new Promise((resolve) => {
            function onSeeked() {
              video.removeEventListener('seeked', onSeeked);
              ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
              resolve();
            }
            video.addEventListener('seeked', onSeeked);
            video.currentTime = time;
          });
        }

        async function downloadZip() {
          if (!frames.value.length) return;
          zipping.value = true;
          try {
            const zip = new JSZip();
            for (let i = 0; i < frames.value.length; i++) {
              const dataUrl = frames.value[i];
              const base64 = dataUrl.split(',')[1];
              zip.file(`${i + 1}.png`, base64, { base64: true });
            }
            const blob = await zip.generateAsync({ type: 'blob' });
            const a = document.createElement('a');
            a.href = URL.createObjectURL(blob);
            a.download = 'frames.zip';
            a.click();
            URL.revokeObjectURL(a.href);
          } finally {
            zipping.value = false;
          }
        }

        return {
          file, fps, frames, processing, zipping, dragging, errorMsg,
          progressStep, progressTotal, progressPct, progressLabel,
          fileSizeMB, triggerFileInput, onFileChange, onDrop, processVideo, downloadZip,
        };
      }
    }).mount('#app');
  </script>
</body>
</html>
